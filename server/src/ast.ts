import { Position } from "vscode-languageserver";

/**
 * Functions to traverse the abstract syntax tree generated by xqlint.
 * 
 * @author Wolfgang Meier
 */
export namespace AST {

	export function findNode(ast: any, pos: Position): any | null {
		let p = ast.pos;
		if (inRange(p, pos, false)) {
			for (let child of ast.children) {
				const n = findNode(child, pos);
				if (n) {
					return n;
				}
			}
			return ast;
		}
		return null;
	}

	function inRange(p: any, pos: Position, exclusive: boolean): boolean {
		if (p && p.sl <= pos.line && pos.line <= p.el) {
			if (p.sl < pos.line && pos.line < p.el) {
				return true;
			} else if (p.sl == pos.line && pos.line < p.el) {
				return p.sc <= pos.character;
			} else if (p.sl == pos.line && p.el == pos.line) {
				return p.sc <= pos.character && pos.character <= p.ec + (exclusive ? 1 : 0);
			} else if (p.sl < pos.line && p.el == pos.line) {
				return pos.character <= p.ec + (exclusive ? 1 : 0);
			}
		}
		return false;
	}

	export function getAncestorOrSelf(type: string, node: any) {
		if (node.name && node.name === type) {
			return node;
		}
		if (node.getParent) {
			return getAncestor(type, node);
		}
		return null;
	}

	export function getAncestor(type: string, node: any): any {
		if (node.getParent) {
			if (node.getParent.name && node.getParent.name === type) {
				return node.getParent;
			}
			return getAncestor(type, node.getParent);
		}
		return null;
	}

	export function getFunctionSignature(node: any): any {
		if (node.name !== 'FunctionCall') {
			return null;
		}
		const name = findChild(node, "EQName");
		const argList = findChild(node, "ArgumentList");
		if (argList) {
			const args = findChildren(argList, "Argument");
			if (args) {
				return {
					args: args,
					name: name.value,
					arity: args.length
				};
			}
		}
	}

	export function findFunctionDecl(node: any, signature: any) {
		const decls = findNodes(node, 'FunctionDecl');
		for (let decl of decls) {
			const name = findChild(decl, 'EQName');
			if (name.value === signature.name) {
				return decl;
			}
		}
	}

	export function findNodes(node: any, type: string, result: any[] = []): any[] {
		if (node.name && node.name === type) {
			result.push(node);
		} else if (node.children) {
			for (let child of node.children) {
				findNodes(child, type, result);
			}
		}
		return result;
	}

	export function findChild(node: any, type: string) {
		if (!node.children) {
			return null;
		}
		for (let child of node.children) {
			if (child.name == type) {
				return child;
			}
		}
		return null;
	}

	export function findChildren(node: any, type: string) {
		if (!node.children) {
			return null;
		}
		let matches = [];
		for (let child of node.children) {
			if (child.name === type) {
				matches.push(child);
			}
		}
		return matches;
	}
}